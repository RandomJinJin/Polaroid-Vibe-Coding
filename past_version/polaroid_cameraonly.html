<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <title>Interactive Polaroid Stack</title>

  <link href="https://fonts.googleapis.com/css2?family=Caveat:wght@500;600&display=swap" rel="stylesheet">

  <style>
    body {
      margin: 0;
      background-image: url("assets/bg.jpg");
      /* ‚Üê ÊîπÊàê‰Ω†ÁöÑ jpg Ë∑ØÂæÑ */
      background-size: cover;
      /* Èì∫Êª°Â±èÂπï */
      background-position: center center;
      /* Â±Ö‰∏≠ */
      background-repeat: no-repeat;
      /* ‰∏çÈáçÂ§ç */
      background-attachment: fixed;
      /* ËßÜÂ∑ÆÊÑüÔºàÂèØÈÄâÔºâ */
      overflow: hidden;
    }

    #mainCanvas {
      position: fixed;
      inset: 0;
      z-index: 1;
    }

    #polaroidCamera {
      position: fixed;
      top: 16px;
      right: 16px;

      width: 260px;
      padding: 14px 14px 38px 14px;
      /* üëà ‰∏ãÊñπÊõ¥ÂÆΩ */

      background: #fff;
      border-radius: 10px;

      box-shadow:
        0 12px 28px rgba(0, 0, 0, 0.35),
        0 2px 6px rgba(0, 0, 0, 0.15);

      z-index: 2;
    }

    #viewFinder {
      width: 100%;
      height: 180px;

      background: #000;
      border-radius: 6px;
      overflow: hidden;

      box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.25);
    }

    #videoCanvas {
      width: 100%;
      height: 100%;
      display: block;
    }
  </style>
</head>

<body>

  <video id="video" autoplay playsinline style="display:none;"></video>
  <canvas id="mainCanvas"></canvas>
  <!-- ‚úÖ Êñ∞Â¢ûÔºöÊãçÁ´ãÂæóÂèñÊôØÂô® -->
  <div id="polaroidCamera">
    <div id="viewFinder">
      <canvas id="videoCanvas"></canvas>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
    /* ================= ÂÜÖÂµåÁÖßÁâá‰ø°ÊÅØ ================= */
    const photoInfoMap = {
      "pic1.jpg": { date: "2023.10.05", desc: "Info1", color: "#555555" },
      "pic2.jpg": { date: "2023.11.12", desc: "Info2", color: "#1a4e8a" },
      "pic3.jpg": { date: "2023.12.24", desc: "Info3", color: "#c92a2a" },
      "pic4.jpg": { date: "2024.01.01", desc: "Info4", color: "#ffcc00" },
      "pic5.jpg": { date: "2024.02.14", desc: "Info5", color: "#FA8072" },
      "pic6.jpg": { date: "2024.03.08", desc: "Info6", color: "#ff6699" },
      "pic7.jpg": { date: "2024.04.01", desc: "Info7", color: "#90EE90" },
      "pic8.jpg": { date: "2024.05.01", desc: "Info8", color: "#6495ED" },
      "pic9.jpg": { date: "2024.06.01", desc: "Info9", color: "#48D1CC" }
    };

    /* ================= Canvas ================= */
    const video = document.getElementById('video');
    const mainCanvas = document.getElementById('mainCanvas');
    const mainCtx = mainCanvas.getContext('2d');
    const videoCanvas = document.getElementById('videoCanvas');
    const videoCtx = videoCanvas.getContext('2d');

    function resizeVideoCanvas() {
      videoCanvas.width = videoCanvas.clientWidth;
      videoCanvas.height = videoCanvas.clientHeight;
    }

    resizeVideoCanvas();
    window.addEventListener('resize', resizeVideoCanvas);


    function resize() {
      mainCanvas.width = innerWidth;
      mainCanvas.height = innerHeight;
    }
    resize();
    addEventListener('resize', resize);

    /* ================= ÂèÇÊï∞ ================= */
    const FOLLOW_GAIN = 0.22;
    const INERTIA_FORCE = 0.08;
    const INERTIA_DAMP = 0.85;
    const SMOOTH = 0.15;

    const N = 10;
    const pieceW = 300;
    const pieceH = 200;
    const scatterOffset = 700;

    /* ================= Êï∞ÊçÆ ================= */
    const stackBase = {
      x: innerWidth / 2, y: innerHeight / 2,
      targetX: innerWidth / 2, targetY: innerHeight / 2,
      vx: 0, vy: 0
    };

    const pieces = [];
    const imageUrls = [
      'images/pic1.jpg', 'images/pic2.jpg', 'images/pic3.jpg',
      'images/pic4.jpg', 'images/pic5.jpg', 'images/pic6.jpg',
      'images/pic7.jpg', 'images/pic8.jpg', 'images/pic9.jpg',
      'images/pic10.jpg' // ‚Üê Êñ∞Â¢û
    ];


    /* ================= ÂàùÂßãÂåñ ================= */
    for (let i = 0; i < N; i++) {
      const img = new Image();
      img.src = imageUrls[i];
      const fileName = imageUrls[i].split('/').pop();

      pieces.push({
        w: pieceW, h: pieceH,
        x: stackBase.x, y: stackBase.y,
        targetX: stackBase.x, targetY: stackBase.y,
        stackOffsetX: (Math.random() - 0.5) * 50,
        stackOffsetY: (Math.random() - 0.5) * 40,
        rotation: (Math.random() - 0.5) * 0.25,
        targetRotation: (Math.random() - 0.5) * 0.25,
        scale: 1, targetScale: 1,
        minScale: 1, maxScale: 2,
        img, fileName,
        info: photoInfoMap[fileName],
        textAlpha: 0,
        vx: 0, vy: 0, vr: 0
      });
    }

    /* ================= ÊâãÂäø ================= */
    let isStacked = true;
    let lastHandState = 'fist';
    let handVisible = false;
    let landmarks = null;
    let grabStart = null;
    let baseStart = null;
    let lastFingerX = null, lastFingerY = null, lastRotateTime = 0;
    let lastGrabX = null;
    let lastGrabY = null;
    let lastFistVelocity = { x: 0, y: 0 };
    let prevHandState = 'none';


    function isFist(lm) { return lm[8].y > lm[5].y; }
    function isOpen(lm) { return [8, 12, 16, 20].every(i => lm[i].y < lm[i - 3].y); }

    /* ================= MediaPipe ================= */
    const hands = new Hands({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.6,
      minTrackingConfidence: 0.6
    });

    hands.onResults(res => {
      if (!res.multiHandLandmarks?.length) {
        handVisible = false; landmarks = null;
        lastFingerX = null; lastFingerY = null;
        return;
      }

      handVisible = true;
      landmarks = res.multiHandLandmarks[0];

      let state = 'none';
      if (isFist(landmarks)) state = 'fist';
      else if (isOpen(landmarks)) state = 'open';

      if (state !== lastHandState) {
        lastHandState = state;

        if (state === 'open') {
          isStacked = false;
          pieces.forEach(p => {
            p.targetX = stackBase.x + (Math.random() - 0.5) * scatterOffset;
            p.targetY = stackBase.y + (Math.random() - 0.5) * scatterOffset;
          });
        }

        if (state === 'fist') {
          isStacked = true;
          grabStart = { x: landmarks[0].x, y: landmarks[0].y };
          baseStart = { x: stackBase.x, y: stackBase.y };
          pieces.forEach(p => p.targetScale = 1);
        }
      }

      // ===== ÊùæÊã≥Áû¨Èó¥ÔºöËΩªÂæÆÂõûÂºπÔºàÊñ∞Â¢ûÔºâ=====
      if (prevHandState === 'fist' && state !== 'fist') {
        // Êï¥‰ΩìÂèçÂêëÂõûÂºπ
        stackBase.vx += -lastFistVelocity.x * 0.45;
        stackBase.vy += -lastFistVelocity.y * 0.45;

        // ÊØèÂº†ÊãçÁ´ãÂæó‰∏çÂêåÁõ∏‰ΩçÁöÑÂõûÂºπ
        pieces.forEach(p => {
          p.vx += -lastFistVelocity.x * (Math.random() * 0.05);
          p.vy += -lastFistVelocity.y * (Math.random() * 0.05);
          p.vr += (Math.random() - 0.5) * 0.015;
        });
      }


      if (isStacked && state === 'fist' && grabStart) {
        const cx = landmarks[0].x * mainCanvas.width;
        const cy = landmarks[0].y * mainCanvas.height;

        const dx = (landmarks[0].x - grabStart.x) * mainCanvas.width * FOLLOW_GAIN;
        const dy = (landmarks[0].y - grabStart.y) * mainCanvas.height * FOLLOW_GAIN;

        stackBase.targetX = baseStart.x + dx;
        stackBase.targetY = baseStart.y + dy;

        if (lastGrabX !== null) {
          const vx = cx - lastGrabX;
          const vy = cy - lastGrabY;

          // ËÆ∞ÂΩïÊúÄÂêé‰∏ÄÊ¨°‚ÄúÊè°Êã≥ÈÄüÂ∫¶‚ÄùÔºå‰æõÊùæÊã≥ÂõûÂºπÁî®
          lastFistVelocity.x = vx;
          lastFistVelocity.y = vy;

          // Êï¥‰ΩìÊÉØÊÄß
          stackBase.vx += vx * 0.18;
          stackBase.vy += vy * 0.18;

          // ===== ÂçïÂº†Âç°ÁâáÔºö‰ΩçÁΩÆ + ÊóãËΩ¨‰∏çÂêåÁõ∏‰ΩçÊäñÂä® =====
          pieces.forEach((p, i) => {
            const phase = i / pieces.length;

            p.vx += vx * (Math.random() * 0.03 + 0.01);
            p.vy += vy * (Math.random() * 0.03 + 0.01);

            p.vr += (Math.random() - 0.5) * 0.004;
          });
        }

        lastGrabX = cx;
        lastGrabY = cy;
      }



      if (!isStacked && state === 'none') {
        const ix = (1 - landmarks[8].x) * mainCanvas.width;
        const iy = landmarks[8].y * mainCanvas.height;

        let nearest = null, minD = Infinity;
        pieces.forEach(p => {
          p.targetScale = 1;
          const d = Math.hypot(p.x - ix, p.y - iy);
          if (d < minD) { minD = d; nearest = p; }
        });

        if (nearest && minD < 200) {
          nearest.targetScale = nearest.maxScale;
          nearest.stackOffsetX = 0;
          nearest.stackOffsetY = -10;

          // ===== ‚≠ê ÊÇ¨ÊµÆË∑üÈöè‰øÆÂ§ç =====
          if (lastFingerX !== null && lastFingerY !== null) {
            const dx = ix - lastFingerX;
            const dy = iy - lastFingerY;

            nearest.targetX += dx * 0.15;
            nearest.targetY += dy * 0.15;
            nearest.targetRotation += dx * 0.0008;

            nearest.vr += (Math.random() - 0.5) * 0.001;
          }

          const idx = pieces.indexOf(nearest);
          if (idx !== -1) { pieces.splice(idx, 1); pieces.push(nearest); }
        }

        lastFingerX = ix;
        lastFingerY = iy;
      }
      prevHandState = state;
    });

    /* ================= ÁªòÂà∂ ================= */
    function draw() {
      videoCtx.clearRect(0, 0, videoCanvas.width, videoCanvas.height);
      videoCtx.drawImage(video, 0, 0, videoCanvas.width, videoCanvas.height);

      // ===== ÊâãÈÉ®È™®È™ºÂèØËßÜÂåñÔºàÊÅ¢Â§çÔºâ=====
      if (handVisible && landmarks) {
        drawConnectors(
          videoCtx,
          landmarks,
          HAND_CONNECTIONS,
          { color: '#00ffaa', lineWidth: 2 }
        );
        drawLandmarks(
          videoCtx,
          landmarks,
          { color: '#ff3355', radius: 3 }
        );
      }


      mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);

      pieces.forEach(p => {
        if (isStacked) {
          p.targetX = stackBase.x + p.stackOffsetX;
          p.targetY = stackBase.y + p.stackOffsetY;
        }

        p.x += (p.targetX - p.x) * SMOOTH + p.vx;
        p.y += (p.targetY - p.y) * SMOOTH + p.vy;
        p.scale += (p.targetScale - p.scale) * SMOOTH;
        p.rotation += (p.targetRotation - p.rotation) * SMOOTH + p.vr;

        p.vx *= 0.8; p.vy *= 0.8; p.vr *= 0.85;

        mainCtx.save();
        mainCtx.translate(p.x, p.y);
        mainCtx.rotate(p.rotation);
        mainCtx.scale(p.scale, p.scale);

        const w = p.w, h = p.h;
        const padTop = 14, padSide = 14, padBottom = 38;

        /* üå´Ô∏è ÊãçÁ´ãÂæóÊäïÂΩ±ÔºàÊÅ¢Â§çÔºâ */
        mainCtx.shadowColor = 'rgba(0,0,0,0.35)';
        mainCtx.shadowBlur = 22;
        mainCtx.shadowOffsetY = 10;

        mainCtx.fillStyle = '#fff';
        mainCtx.beginPath();
        mainCtx.roundRect(-w / 2, -h / 2, w, h, 8);
        mainCtx.fill();

        /* ÂÖ≥Èó≠Èò¥ÂΩ±ÔºåÈÅøÂÖçÊ±°ÊüìÂõæÁâáÂíåÊñáÂ≠ó */
        mainCtx.shadowColor = 'transparent';
        mainCtx.shadowBlur = 0;
        mainCtx.shadowOffsetY = 0;

        if (p.img.complete) {
          mainCtx.drawImage(
            p.img,
            -w / 2 + padSide,
            -h / 2 + padTop,
            w - padSide * 2,
            h - padTop - padBottom
          );
        }

        /* ===== ÊñáÂ≠óÊ∏êÊòæ ===== */
        const targetAlpha = p.scale > 1.05 ? 1 : 0;
        p.textAlpha += (targetAlpha - p.textAlpha) * 0.12;

        if (p.info && p.textAlpha > 0.01) {
          mainCtx.globalAlpha = p.textAlpha;
          mainCtx.fillStyle = p.info.color;
          mainCtx.font = '18px Caveat, cursive';

          mainCtx.textAlign = 'left';
          mainCtx.fillText(p.info.date, -w / 2 + 18, h / 2 - 10);

          mainCtx.textAlign = 'right';
          mainCtx.fillText(p.info.desc, w / 2 - 18, h / 2 - 10);
        }

        mainCtx.globalAlpha = 1;
        mainCtx.restore();
      });

      requestAnimationFrame(draw);
    }

    /* ================= Camera ================= */
    const camera = new Camera(video, {
      onFrame: async () => hands.send({ image: video }),
      width: 640, height: 480
    });
    camera.start();
    draw();

  </script>

</body>

</html>