<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <title>Interactive Polaroid Stack</title>

  <link href="https://fonts.googleapis.com/css2?family=Caveat:wght@500;600&display=swap" rel="stylesheet">

  <style>
    body {
      margin: 0;
      background: #111;
      overflow: hidden;
    }

    #mainCanvas {
      position: fixed;
      inset: 0;
      z-index: 1;
    }

    #videoCanvas {
      position: fixed;
      top: 16px;
      right: 16px;
      width: 240px;
      height: 180px;
      border: 1px solid #333;
      background: #000;
      z-index: 2;
    }
  </style>
</head>

<body>

  <video id="video" autoplay playsinline style="display:none;"></video>
  <canvas id="mainCanvas"></canvas>
  <canvas id="videoCanvas"></canvas>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
    /* ================= å†…åµŒç…§ç‰‡ä¿¡æ¯ ================= */
    const photoInfoMap = {
      "pic1.jpg": { date: "2023.10.05", desc: "ç§‹æ—¥é‡é¤", color: "#555555" },
      "pic2.jpg": { date: "2023.11.12", desc: "æµ·è¾¹è½æ—¥", color: "#1a4e8a" },
      "pic3.jpg": { date: "2023.12.24", desc: "å¹³å®‰å¤œ", color: "#c92a2a" },
      "pic4.jpg": { date: "2024.01.01", desc: "æ–°å¹´å¿«ä¹", color: "#ffcc00" },
      "pic5.jpg": { date: "2024.02.14", desc: "æƒ…äººèŠ‚", color: "#ff6699" },
      "pic6.jpg": { date: "2024.03.08", desc: "å¦‡å¥³èŠ‚", color: "#ff6699" },
      "pic7.jpg": { date: "2024.04.01", desc: "æ„šäººèŠ‚", color: "#ff6699" },
      "pic8.jpg": { date: "2024.05.01", desc: "åŠ³åŠ¨èŠ‚", color: "#ff6699" },
      "pic9.jpg": { date: "2024.06.01", desc: "å„¿ç«¥èŠ‚", color: "#ff6699" }
    };

    /* ================= Canvas ================= */
    const video = document.getElementById('video');
    const mainCanvas = document.getElementById('mainCanvas');
    const mainCtx = mainCanvas.getContext('2d');
    const videoCanvas = document.getElementById('videoCanvas');
    const videoCtx = videoCanvas.getContext('2d');

    function resize() {
      mainCanvas.width = innerWidth;
      mainCanvas.height = innerHeight;
    }
    resize();
    addEventListener('resize', resize);

    /* ================= å‚æ•° ================= */
    const FOLLOW_GAIN = 0.22;
    const INERTIA_FORCE = 0.08;
    const INERTIA_DAMP = 0.85;
    const SMOOTH = 0.15;

    const N = 9;
    const pieceW = 300;
    const pieceH = 200;
    const scatterOffset = 700;

    /* ================= æ•°æ® ================= */
    const stackBase = {
      x: innerWidth / 2, y: innerHeight / 2,
      targetX: innerWidth / 2, targetY: innerHeight / 2,
      vx: 0, vy: 0
    };

    const pieces = [];
    const imageUrls = [
      'images/pic1.jpg', 'images/pic2.jpg', 'images/pic3.jpg',
      'images/pic4.jpg', 'images/pic5.jpg', 'images/pic6.jpg',
      'images/pic7.jpg', 'images/pic8.jpg', 'images/pic9.jpg'
    ];

    /* ================= åˆå§‹åŒ– ================= */
    for (let i = 0; i < N; i++) {
      const img = new Image();
      img.src = imageUrls[i];
      const fileName = imageUrls[i].split('/').pop();

      pieces.push({
        w: pieceW, h: pieceH,
        x: stackBase.x, y: stackBase.y,
        targetX: stackBase.x, targetY: stackBase.y,
        stackOffsetX: (Math.random() - 0.5) * 50,
        stackOffsetY: (Math.random() - 0.5) * 40,
        rotation: (Math.random() - 0.5) * 0.25,
        targetRotation: (Math.random() - 0.5) * 0.25,
        scale: 1, targetScale: 1,
        minScale: 1, maxScale: 2,
        img, fileName,
        info: photoInfoMap[fileName],
        textAlpha: 0,
        vx: 0, vy: 0, vr: 0
      });
    }

    /* ================= æ‰‹åŠ¿ ================= */
    let isStacked = true;
    let lastHandState = 'fist';
    let handVisible = false;
    let landmarks = null;
    let grabStart = null;
    let baseStart = null;
    let lastFingerX = null, lastFingerY = null, lastRotateTime = 0;
    let lastGrabX = null;
    let lastGrabY = null;
    let lastFistVelocity = { x: 0, y: 0 };
    let prevHandState = 'none';





    function isFist(lm) { return lm[8].y > lm[5].y; }
    function isOpen(lm) { return [8, 12, 16, 20].every(i => lm[i].y < lm[i - 3].y); }

    /* ================= MediaPipe ================= */
    const hands = new Hands({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.6,
      minTrackingConfidence: 0.6
    });

    hands.onResults(res => {
      if (!res.multiHandLandmarks?.length) {
        handVisible = false; landmarks = null;
        lastFingerX = null; lastFingerY = null;
        return;
      }

      handVisible = true;
      landmarks = res.multiHandLandmarks[0];

      let state = 'none';
      if (isFist(landmarks)) state = 'fist';
      else if (isOpen(landmarks)) state = 'open';

      if (state !== lastHandState) {
        lastHandState = state;

        if (state === 'open') {
          isStacked = false;
          pieces.forEach(p => {
            p.targetX = stackBase.x + (Math.random() - 0.5) * scatterOffset;
            p.targetY = stackBase.y + (Math.random() - 0.5) * scatterOffset;
          });
        }

        if (state === 'fist') {
          isStacked = true;
          grabStart = { x: landmarks[0].x, y: landmarks[0].y };
          baseStart = { x: stackBase.x, y: stackBase.y };
          pieces.forEach(p => p.targetScale = 1);
        }
      }

      // ===== æ¾æ‹³ç¬é—´ï¼šè½»å¾®å›å¼¹ï¼ˆæ–°å¢ï¼‰=====
      if (prevHandState === 'fist' && state !== 'fist') {
        // æ•´ä½“åå‘å›å¼¹
        stackBase.vx += -lastFistVelocity.x * 0.45;
        stackBase.vy += -lastFistVelocity.y * 0.45;

        // æ¯å¼ æ‹ç«‹å¾—ä¸åŒç›¸ä½çš„å›å¼¹
        pieces.forEach(p => {
          p.vx += -lastFistVelocity.x * (Math.random() * 0.05);
          p.vy += -lastFistVelocity.y * (Math.random() * 0.05);
          p.vr += (Math.random() - 0.5) * 0.015;
        });
      }


      if (isStacked && state === 'fist' && grabStart) {
        const cx = landmarks[0].x * mainCanvas.width;
        const cy = landmarks[0].y * mainCanvas.height;

        const dx = (landmarks[0].x - grabStart.x) * mainCanvas.width * FOLLOW_GAIN;
        const dy = (landmarks[0].y - grabStart.y) * mainCanvas.height * FOLLOW_GAIN;

        stackBase.targetX = baseStart.x + dx;
        stackBase.targetY = baseStart.y + dy;

        if (lastGrabX !== null) {
          const vx = cx - lastGrabX;
          const vy = cy - lastGrabY;

          // è®°å½•æœ€åä¸€æ¬¡â€œæ¡æ‹³é€Ÿåº¦â€ï¼Œä¾›æ¾æ‹³å›å¼¹ç”¨
          lastFistVelocity.x = vx;
          lastFistVelocity.y = vy;

          // æ•´ä½“æƒ¯æ€§
          stackBase.vx += vx * 0.18;
          stackBase.vy += vy * 0.18;

          // ===== å•å¼ å¡ç‰‡ï¼šä½ç½® + æ—‹è½¬ä¸åŒç›¸ä½æŠ–åŠ¨ =====
          pieces.forEach((p, i) => {
            const phase = i / pieces.length;

            p.vx += vx * (Math.random() * 0.03 + 0.01);
            p.vy += vy * (Math.random() * 0.03 + 0.01);

            p.vr += (Math.random() - 0.5) * 0.004;
          });
        }

        lastGrabX = cx;
        lastGrabY = cy;
      }



      if (!isStacked && state === 'none') {
        const ix = (1 - landmarks[8].x) * mainCanvas.width;
        const iy = landmarks[8].y * mainCanvas.height;

        let nearest = null, minD = Infinity;
        pieces.forEach(p => {
          p.targetScale = 1;
          const d = Math.hypot(p.x - ix, p.y - iy);
          if (d < minD) { minD = d; nearest = p; }
        });

        if (nearest && minD < 200) {
          nearest.targetScale = nearest.maxScale;
          nearest.stackOffsetX = 0;
          nearest.stackOffsetY = -10;

          const idx = pieces.indexOf(nearest);
          if (idx !== -1) { pieces.splice(idx, 1); pieces.push(nearest); }
        }

        lastFingerX = ix;
        lastFingerY = iy;
      }
      prevHandState = state;
    });

    /* ================= ç»˜åˆ¶ ================= */
    function draw() {
      videoCtx.clearRect(0, 0, videoCanvas.width, videoCanvas.height);
      videoCtx.drawImage(video, 0, 0, videoCanvas.width, videoCanvas.height);

      // ===== æ‰‹éƒ¨éª¨éª¼å¯è§†åŒ–ï¼ˆæ¢å¤ï¼‰=====
      if (handVisible && landmarks) {
        drawConnectors(
          videoCtx,
          landmarks,
          HAND_CONNECTIONS,
          { color: '#00ffaa', lineWidth: 2 }
        );
        drawLandmarks(
          videoCtx,
          landmarks,
          { color: '#ff3355', radius: 3 }
        );
      }


      mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);

      pieces.forEach(p => {
        if (isStacked) {
          p.targetX = stackBase.x + p.stackOffsetX;
          p.targetY = stackBase.y + p.stackOffsetY;
        }

        p.x += (p.targetX - p.x) * SMOOTH + p.vx;
        p.y += (p.targetY - p.y) * SMOOTH + p.vy;
        p.scale += (p.targetScale - p.scale) * SMOOTH;
        p.rotation += (p.targetRotation - p.rotation) * SMOOTH + p.vr;

        p.vx *= 0.8; p.vy *= 0.8; p.vr *= 0.85;

        mainCtx.save();
        mainCtx.translate(p.x, p.y);
        mainCtx.rotate(p.rotation);
        mainCtx.scale(p.scale, p.scale);

        const w = p.w, h = p.h;
        const padTop = 14, padSide = 14, padBottom = 38;

        /* ğŸŒ«ï¸ æ‹ç«‹å¾—æŠ•å½±ï¼ˆæ¢å¤ï¼‰ */
        mainCtx.shadowColor = 'rgba(0,0,0,0.35)';
        mainCtx.shadowBlur = 22;
        mainCtx.shadowOffsetY = 10;

        mainCtx.fillStyle = '#fff';
        mainCtx.beginPath();
        mainCtx.roundRect(-w / 2, -h / 2, w, h, 8);
        mainCtx.fill();

        /* å…³é—­é˜´å½±ï¼Œé¿å…æ±¡æŸ“å›¾ç‰‡å’Œæ–‡å­— */
        mainCtx.shadowColor = 'transparent';
        mainCtx.shadowBlur = 0;
        mainCtx.shadowOffsetY = 0;

        if (p.img.complete) {
          mainCtx.drawImage(
            p.img,
            -w / 2 + padSide,
            -h / 2 + padTop,
            w - padSide * 2,
            h - padTop - padBottom
          );
        }

        /* ===== æ–‡å­—æ¸æ˜¾ ===== */
        const targetAlpha = p.scale > 1.05 ? 1 : 0;
        p.textAlpha += (targetAlpha - p.textAlpha) * 0.12;

        if (p.info && p.textAlpha > 0.01) {
          mainCtx.globalAlpha = p.textAlpha;
          mainCtx.fillStyle = p.info.color;
          mainCtx.font = '18px Caveat, cursive';

          mainCtx.textAlign = 'left';
          mainCtx.fillText(p.info.date, -w / 2 + 18, h / 2 - 10);

          mainCtx.textAlign = 'right';
          mainCtx.fillText(p.info.desc, w / 2 - 18, h / 2 - 10);
        }

        mainCtx.globalAlpha = 1;
        mainCtx.restore();
      });

      requestAnimationFrame(draw);
    }

    /* ================= Camera ================= */
    const camera = new Camera(video, {
      onFrame: async () => hands.send({ image: video }),
      width: 640, height: 480
    });
    camera.start();
    draw();
  </script>

</body>

</html>